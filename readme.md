**Необходимо поправить**
1) Проверить отображение координат точко, в верхней части нужно чтобы сдвигало, а не рисовало по центру

**Доделать**
Сменить Ka Kb на выподающий список со всеми возможными линиями

**Полезные команды**

pyinstaller ODPDO.spec
pyinstaller 32/ODPDO_32.spec
python -c "import xraydb; import os; import inspect; print('xraydb at', os.path.dirname(inspect.getfile(xraydb)))"

АЛГОРИТМ
Приём данных. Потоки SerialTask/PacketTask открывают COM‑порт, отправляют символ T для запуска и в цикле вызывают Survey_, который ждёт событие EV_RXCHAR, читает накопившиеся байты и передаёт их в ParseStream_.
Фрейминг 12‑битных чисел. ParseStream_ перебирает байты MASK_LOW → MASK_HIGH → MASK_LOW → MASK_HIGH2, проверяя порядок. Первые два байта склеиваются в Rest.wFirst, следующие два — в Rest.wSecond. Каждый байт содержит 6 младших бит значения и 2 бита типа (маски 0x00, 0x40, 0x80). При нарушении последовательности шлёт TSM_ERROR.

Фильтр недопустимых значений. Если любой из 12‑битных результатов равен 0 либо 0xFFF (RANGE_SPAN), пара отбрасывается.
Получение итогового номера канала. Когда оба числа валидны, вычисляется нормированное значение (канал) и через TSM_VALUE отправляется в окно вместе с исходной парой.
Формула итогового номера канала
Пусть A = Rest.wFirst, B = Rest.wSecond, а RANGE_SPAN = 0xFFF = 4095. Тогда итоговый 12‑битный номер канала Value вычисляется по формуле:
или эквивалентно:
(вторая форма получается после упрощения). Результат округляется к ближайшему целому (0.5 добавляется перед приведением к WORD).


**COM**

python 32/COM_v2.py --port COM1 --baud 9600 --duration 5
python 32/COM_v2.py --simulate --samples 1000 --plot --sim-delay 0.2  # ~5 сигналов/сек по умолчанию

**Алгоритм COM_v2.py**

1. SerialConfig задаёт полное описание порта: `port` (строка `COM3` и т.п.), `baudrate`, `parity` (символьные значения pyserial), `stopbits`, `timeout`. ComChannelReader использует pyserial для открытия дескриптора, сразу очищает буферы RX/TX, посылает управляющий байт `CHR_START = 'T' (0x54)` и далее в цикле читает блоки размером `chunk_size` (по умолчанию 512 байт). Каждое поступление прокидывается в RangeParser. По завершении окна экспозиции отправляется `CHR_STOP = 'P' (0x50)` и порт закрывается. Для интеграции доступны два метода: `iter_measurements()` (ленивая генерация, удобно для live-графика) и `collect()` (полный список значений).
2. RangeParser реализует побитовый FSM из ParseStream_. Каждому байту соответствуют два старших бита порядка (`MASK_ORDER = 0xC0`) и шесть младших бит полезных данных (`MASK_VALUE = 0x3F`). Порядок обязательный:  
   - `MASK_LOW (0b00xxxxxx)` — нижние 6 бит первого 12-битного числа.  
   - `MASK_HIGH (0b01xxxxxx)` — верхние 6 бит того же числа (сдвигаются << 6 и OR с предыдущим байтом).  
   - `MASK_LOW` снова — нижние 6 бит второго числа.  
   - `MASK_HIGH2 (0b10xxxxxx)` — верхние 6 бит второго числа.  
   Таким образом 12-битное значение формируется из двух подряд идущих 6-битных кусков (без пропусков, просто сдвиг/OR). Если приходит `MASK_OVER (0b11xxxxxx)` вместо `MASK_HIGH2`, это сигнал переполнения, пара сбрасывается. Любое нарушение порядка мгновенно переводит автомат в состояние `EMPTY`, байт отбрасывается. После склейки проверяется, что оба числа не равны 0 и 0xFFF (RANGE_SPAN).
3. Расчёт канала повторяет оригинальный код: `Value = round(0.5 * ((A - B)/(A + B) + 1.0) * RANGE_SPAN)`. Фактически это нормировка разности на сумму с переводом в диапазон 0..4095. Вычисление выполняет `_calc_channel`, а результат упаковывается в `RangeMeasurement(channel_value=A/B)` вместе с исходными A и B; эти структуры идут далее в вывод или live-график.
4. Для тестов добавлен симулятор: `generate_simulated_bytes()` строит синусоидальный профиль с шумом, `_encode_pair()` нарезает 12-битные величины на байты, `simulated_measurement_stream()` выдаёт измерения с заданной частотой (`--sim-delay`, по умолчанию 0.2 c ≈ 5 Гц).
5. Live-график (`plot_live_histogram`) принимает любой итератор измерений, в том числе реальный порт, и отображает накопление попаданий в каналы в пределах 0–4095. Интерактивный режим держит окно открытым до ручного закрытия.
6. CLI поддерживает два режима:
   - реальный порт: `--port`, `--baud`, `--duration`, `--chunk`;
   - симуляция: `--simulate`, `--samples`, `--sim-delay`, `--seed`.
   Для обоих режимов по желанию включается график (`--plot --refresh <сек>`); без графика значения выводятся в терминал.

